#################C++#################
1.
extern声明放头文件，定义放源文件；extern声明类型要和定义类型一样；
static即使修饰的是全局变量，它的作用域也只能是本编译单元（cpp文件），因此将static全局变量放在源文件；
static用法1: 用于局部变量，扩展生存期；
static用法2: 用于全局变量，限制作用域；普通全局变量的作用域为整个项目，static全局变量的作用域为当前cpp文件； 
static用法3: 用于类成员变量或成员函数，提供数据唯一性；

2.
常量指针与指针常量

常量指针：指向常量的指针（也可以指向变量）；
用法：const int *p = &var1; int const *p = &var1;
不能通过指针修改所指对象（*p = xx; 错），可以更改指针的指向（p = &var2; 对）

指针常量：指针本身是个常量，在声明时必须初始化指向一个变量；
用法：int * const p = &var1;
可以通过指针修改所指对象（*p = xx; 对），不能更改指针对指向（p = &var2; 错）

3.
引用对语义在底层是通过 指针常量 实现的，所以引用在声明时必须初始化，且可以通过引用修改所指对象。因此引用在底层占用一个指针的内存大小；

4. 
不能建立引用数组是说：数组的元素不能是引用（int &arr[num]; 错），因为引用只能在初始化时绑定到一个对象上；但是可以建立数组的引用（int(& arr)[num]; 对）

5. 
数组对降阶：
数组作为函数参数时，退化成一个普通指针，size为一个指针的大小：
解决办法1: 在参数中增加数组的长度len作为参数
解决办法2: 使用数组的引用作为参数，例如：void test(int (&arr)[20]);

6.
结构体零大小数组：用于变长结构体
优点：零大小数组只是一个占位符（因为数组名本身代表一个不可以修改的常量地址，它指向结构体最后紧邻的空间，不占用空间），因此一次内存分配即可分配到一段连续的内存地址，释放时也只需释放一次。
例如：
struct ppoe_tag {
	__u16 tag_type;
	__u16 tag_len;
	char *tag_data;
} __attribute ((packed));

创建：
struct ppoe_tag *sample_tag;
__u16 sample_tag_len = 10;
sample_tag = (struct ppoe_tag *)malloc(sizeof(struct ppoe_tag) + sizeof(char) * sample_tag_len);
sample_tag->tag_type = 0xffff;
sample_tag->tag_len = sample_tag_len;
memcpy(sample_tag->tag_data, "datas...", sample_tag_len);

释放：
free(sample_tag);

7. 
为什么拷贝构造函数参数一定是传引用？为什么不能是传指针？
首先，不能是传值（会造成递归调用拷贝构造函数，死循环）
然后，传指针确实不会造成死循环问题，但是你得自己实现编译器让它知道发生拷贝的时候去调用你写的传指针的那个函数，因为传指针在调用处就不是拷贝的语义了；
另外，指针本身是一个变量，只不过它的值是另一个变量的地址而已；所以说传指针也是值传递；

8.
在使用迭代器的循环体内，不要向迭代器所属容器添加元素，因为这会使迭代器失效；

9.
字符数组：char arr[] = "C++"; 自动添加结束符'\0'，因此它的大小是4

10.
函数重载（同一作用域内的名字相同，形参不同的函数构成重载）
顶层const形参不能构成重载：
int lookup(int); 与 int lookup(const int); 重复声明
int lookup(int*); 与 int lookup(int* const); 重复声明

底层const形参可以构成重载（通过实参类型来区分）：
int lookup(int &); 与 int lookup(const int&); 根据实参是常量还是非常量进行区分
int lookup(int*); 与 int lookup(const int*); 根据实参是常量还是非常量进行区分

类成员函数的const重载（因为只有const对象可以调用const成员函数，在调用时有个隐式参数const this指针，通过整个隐式参数的不同来区分）
class Screen{
public:
	Screen& display(ostream &os)
	{
		do_display(os);
		return *this;
	}

	const Screen& display(ostream &os) const
	{
		do_display(os);
		return *this;
	}

private:
	void do_display(ostream &os)
	{
		os<< contents;
	}

	string contents;
};

11.
类构造函数的初始值列表是对const，引用和类类型进行初始化的地方，构造函数方法体内是赋值而不是初始化
class ConstRef{
public:
	ConstRef(int ii);
private:
	int i;
	const int ci;
	int &ri;
};

ConstRef::ConstRef(int ii)
{
	i = ii; //内置类型赋值，正确
	ci = ii; //错误，不能给const赋值
	ri = i; //错误，引用必须先初始化
}
//使用初始化列表完成初始化，正确；另外初始化列表里的初始化顺序是又类成员变量的定义顺序决定的
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i)
{
}

12.
只有一个参数的构造函数又叫转换构造函数，它可以隐式的将其他类型转换成当前类类型。将此种构造函数声明为explict可以阻止这种隐式转换（隐式转换一般在拷贝初始化时发送）；explict构造函数只能用于显示初始化；


#################go#################
#################java###############
#################mysql##############
