# 杂记

### Mybatis使用

~~~xml
Mybatis使用：

1. pom.xml文件加mysql和mybatis依赖：
<dependencies>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.31</version>
    </dependency>

    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.1.1</version>
    </dependency>
</dependencies>

2. resource下新建mybatis_config.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC" />
            <!-- 配置数据库连接信息 -->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver" />
                <property name="url" value="jdbc:mysql://localhost:3306/jfinal_demo?characterEncoding=utf8" />
                <property name="username" value="root" />
                <property name="password" value="12345678" />
            </dataSource>
        </environment>
    </environments>

    <mappers>
        <mapper resource="com/leo/UserMapper.xml"/>
    </mappers>

</configuration>

3. resource下进行com/leo/UserMapper.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.leo.UserMapper">

    <!--
        根据id查询得到一个user对象
     -->
    <select id="getUser" parameterType="int"
            resultType="com.leo.User">
        select * from user where id=#{id}
    </select>
</mapper>

4. 新建src/main/java/com/leo/User.java文件，定义PO对象User
5. 新建src/main/java/com/leo/UserMapper.java文件，定义User操作接口
6. 新建测试Main.java

run-error：Caused by: java.lang.NullPointerException
	at com.mysql.jdbc.ConnectionImpl.getServerCharacterEncoding
原因：mysql driver: 5.1.31 问题
升级 mysql driver to 5.1.44，OK

~~~

### 前端

> JavaScript runtime environment： Node.js
> package manager：npm
> package.json管理依赖包版本：语法：~ 与 ^
>
> ~~~
> {
>  "devDependencies": {
>    "ember-cli": "~1.0.1"
>  }
> }
> ~~~
>
> ~~~
> major.minor.patch
> 1.0.2
> ~~~
>
> npm uses the tilde (~) and caret (^) to designate which patch and minor versions to use respectively.
>
> So if you see `~1.0.2` it means to install version `1.0.2` or the latest patch version such as `1.0.4`. If you see `^1.0.2` it means to install version `1.0.2` or the latest minor or patch version such as `1.1.0`.
>
> TypeScript语法：https://www.tslang.cn/docs/home.html
>
> tsconfig.json：添加TypeScript文件的编译选项等
>
> JavaScript语法：https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000
>
> UI库：primeng
>
> 【查看npm镜像源: npm config get registry】
> 【设置npm镜像源: npm config set registry url】
>
> angular 应用打包部署:
> npm install -g @angular/cli （安装ng）
> ng build --output-path=release/ --configuration=test (package.json + environments/environment.test.ts)

### Java 泛型方法与可变参数的bug

~~~
java 泛型方法与可变参数的bug：反编译查看类型转换的错误

    public static void main(String[] args) {
        test ( arg() );
    }

    public static void test(Object... args) {
        System.out.println ( args );
    }

    public static <T> T arg() {
        return (T) "df";
    }
    
    反编译后的代码：
    
    public static void main(String[] args) {
        test ((Object[]) arg() ); //此处会报类型转换的错
    }

    public static void test(Object... args) {
        System.out.println ( args );
    }:

    public static Object arg() {
        return "df";
    }
   
  翻墙：
wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log
~~~

### spring-security

~~~
浏览器同源(协议+域名+端口)政策： http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html
浏览器同源政策限制了：不同源的请求
1. cookie和LocalStorage不能共享
2. DOM无法获取
3. AJAX请求不能发送

同源政策规定，AJAX请求只能发给同源的网址，否则就报错。规避这个限制的方法有三种：
1. JSONP：利用javascript脚本可以跨源
2. WebSocket：该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信
3. CORS：W3C标准，它允许浏览器向跨源服务器，发出XMLHttpRequest请求

cors: Cross-Origin Resource Sharing，是跨源AJAX请求的根本解决方法
关键点：浏览器在跨域请求里带上Origin字段；服务器响应带上Access-Control-Allow-Origin字段

xss: Cross-Site Scripting，跨域脚本攻击
攻击方式：在允许用户输入输出的地方插入恶意javascript
预防：对输入输出参数都需要进行过滤转义

SQL注入: 通过操作输入来修改后台SQL语句达到代码执行进行攻击目的的技术
攻击方式：通过在输入参数里加入SQL代码，比如where字句传入恒等表达式
预防：对参数进行过滤和转义

CRSF: Cross Site Request Forgery, 跨域请求伪造。攻击者盗用了你的身份，以你的名义发送恶意请求。

为什么会有CSRF?
JavaScript控制浏览器发送请求的时候，浏览器是根据目标站点，而不是来源站点，来发送cookie的，如果当前会话中有目标站点的cookie，就发送出去。核心问题是浏览器的会话机制，是跨站请求伪造漏洞的根源。

一次CRSF攻击：
1. 登录受信任网站A，并在本地生成Cookie。
2. 在不登出A的情况下，访问危险网站B。（攻击方式分get、post方式）

防范方法：CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。

1. 加入token
2. 敏感操作使用post请求，防止token暴露在url中
3. 使用http协议的refer值，检测发起请求的网址是否合法
~~~

### Http状态码

101 - Switching Protocols

200 - OK

301 - 重定向

4xx -  客户端错误 (404 - Not Found / 403 - Forbidden / 400 - Bad Request / 401 - Unauthorized)

5xx - 服务器错误 (500 - Internal Server Error / 502 - Bad Gateway / 503 - Service Unavailable / 504 - Gateway Time-out)

### WEB登录认证

> 参考： http://ayuliao.com/2017/11/18/浅谈Cookie、Session和JWT三种用户认证方式/
>
> 1. cookie
> 2. session
> 3. token

### XML 解析

1. 编写xml schema文档，规定xml的书写规范
2. 编写xml文档
3. 解析xml（期间会根据xml schema来验证xml文档是否符合规范）

### 加密算法

1. MD5（Message-Digest Algorithm 5th，一种密码hash函数）

   应用：对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。

   典型应用：下载软件时，都有提供一个md5值，下载完成后在本地进行md5验证以确保下载的软件是正确的。

2. SHA256（Secure Hash Algorithm - 256bit，一种密码hash函数）

   应用：对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。

   典型应用：同MD5，但比MD5的破解难度更大，更安全。

3. HMAC （Hash-based Message Authentication Code：H代表所采用的hash算法如MD5，SHA256等）

   应用：以一个密钥和一个消息为输入，生成一个消息摘要作为输出。用于身份认证。

   典型应用：

   (1) 客户端发出登录请求（假设是浏览器的GET请求）

   (2) 服务器返回一个随机值，并在会话中记录这个随机值

   (3) 客户端将该随机值作为密钥，和用户密码进行hmac运算，然后提交给服务器

   (4) 服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的hmac运算，然后与用户发送的结果比较，如果结果一致则验证用户合法

4. DES（一种对称加密算法[加密解密时使用同一个密钥]）

   应用：

   (1) 加密（key[密钥] + data[待加密数据] + mode[加密]）

   (2) 解密（key[密钥] + data[待解密数据] + mode[解密]）

5. RSA（一种非对称加密算法 [公钥密钥]）

   应用：对少量数据进行加密（因为加密速度很慢）

   典型应用1：加密解密 （此时：**公钥负责加密，私钥负责解密**）

   （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。

   （2）甲方获取乙方的公钥，然后用它对信息加密。

   （3）乙方得到加密后的信息，用私钥解密。

   典型应用2：数字签名（此时：**私钥负责签名，公钥负责验证**）

   （1）发送方先产生成一对密钥，并将公钥公开给接收方；

   （2）发送方将数据D用MD5/SHA/HMAC等进行消息摘要，得到Q；

   （3）用私钥对Q进行加密（签名）得到密文MQ，然后将数据D和密文MQ一起发送给接收方；

   （4）接收方得到数据D和密文MQ后，用公钥将密文MQ解密（验证）得到Q1；

   （5）接收方使用相同的算法对数据D进行消息摘要，得到Q2；

   （6）比较Q1和Q2，相等则证明D是由发送方发送的，且没有被修改过。